/******************************************************************************/
/**	
*   @class CSCClient
*	@brief implementation file of CSCClient class.
*	@version 2009.12.14: The first version that generated by VC .Net
*/
/******************************************************************************/

#include "stdafx.h"
#include "SCAPI.h"
#include "SCClient.h"
#include <afxpriv.h>
#include "SCSocket.h"
#include "delegate.h"
#include "Service.h"
#include "SysException.h"
#include "SCException.h"
#include "DebugLog.h"
#include "scclienthelper.h"
#include "scgenericack.h"
#include "scgenericnack.h"
#include "SCCommand.h"
#include "validation.h"
#include "scapi.h"
#include "scconnectrequest.h"
#include "scconnectrequestreply.h"
#include "scdatamsg.h"
#include "scdatamsgreply.h"
#include "scenquirelink.h"
#include "scenquirelinkreply.h"
#include "FuncCommand.h"
#include "SCResponseCommand.h"
#include <memory>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define __FILENAME__ _T("")

#define  theSC_Client_Data CFileLog::GetInstance(FILTER_SC_CLIENT_DATA)
#define theSC_Client_Trace CFileLog::GetInstance(FILTER_SC_CLIENT_LOG)

#define SC_MSG_EXEC_COMMAND					 0X6100
#define SC_MSG_POST_MESSAGE						  0X6101

#define CLOSEFROMLOCALCODE					 0xFFFF

BEGIN_MESSAGE_MAP(CSCClient,CUtilThread)
	ON_THREAD_MESSAGE(SC_MSG_EXEC_COMMAND,OnExecCommand)
	ON_THREAD_MESSAGE(SC_MSG_POST_MESSAGE,OnPostCommand)
END_MESSAGE_MAP()

CSCClient CSCClient::instance;

//////////////////////////////////////////////////////////////////////////
/**
@brief      构造函数
@param      none
@retval     none
*/
//////////////////////////////////////////////////////////////////////////
CSCClient::CSCClient()
{
	m_Helper = NULL;
	m_Socket = NULL;
	m_HostSvc = NULL;
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      初期化

@param      SCClientParameter& 客户端配置参数

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::Initialize(SCClientParameter& parameter)
{
	m_PauseSend = false;
	this->m_bAutoDelete = false;
	AfxSocketInit();
	ASSERT(parameter.hostSvc != NULL);
	this->m_Parameter = parameter;
	this->m_HostSvc = parameter.hostSvc;
	m_Helper = new CSCClientHelper;
	m_Helper->SetTimerInterval(parameter.enquireLinkInterval,parameter.sendTimeOutInterval,parameter.receiveTimeOutInterval);
	this->m_Socket = new CSCSocket;

	m_Socket->Receiving.AddHandler(this,&CSCClient::OnSocketStartReceiveOneMessage);
	m_Socket->Received.AddHandler(this,&CSCClient::OnSocketEndReceiveOneMessage);
	m_Socket->Sending.AddHandler(this,&CSCClient::OnSocketStartSendOneMessage);
	m_Socket->Sended.AddHandler(this,&CSCClient::OnSocketEndSendOneMessage);
	m_Socket->Closed.AddHandler(this,&CSCClient::OnSocketClosed);

	m_Helper->ReceiveTimeouted.AddHandler(this,&CSCClient::OnReceiveTimeout);
	m_Helper->SendTimeouted.AddHandler(this,&CSCClient::OnSendTimeout);
	m_Helper->EnquireLinked.AddHandler(this,&CSCClient::OnEnquirelink);
	m_LocalCommand = NULL;
	
	CUtilThread::StartThread(this);
}

//////////////////////////////////////////////////////////////////////////
/**
@brief      析构函数
@param      none
@retval     none
*/
//////////////////////////////////////////////////////////////////////////
CSCClient::~CSCClient()
{

}

//////////////////////////////////////////////////////////////////////////
/*
@brief      关闭

@param      无

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::Shutdown()
{
	
	m_PauseSend = true;
	m_Socket->Receiving.RemoveHandler(this,&CSCClient::OnSocketStartReceiveOneMessage);
	m_Socket->Received.RemoveHandler(this,&CSCClient::OnSocketEndReceiveOneMessage);
	m_Socket->Sending.RemoveHandler(this,&CSCClient::OnSocketStartSendOneMessage);
	m_Socket->Sended.RemoveHandler(this,&CSCClient::OnSocketEndSendOneMessage);
	m_Socket->Closed.RemoveHandler(this,&CSCClient::OnSocketClosed);
	Close();
	//m_Socket->Close();
	delete m_Socket;
	m_Socket = NULL;

	m_Helper->ReceiveTimeouted.RemoveHandler(this,&CSCClient::OnReceiveTimeout);
	m_Helper->SendTimeouted.RemoveHandler(this,&CSCClient::OnSendTimeout);
	m_Helper->EnquireLinked.RemoveHandler(this,&CSCClient::OnEnquirelink);
	delete m_Helper;
	m_Helper = NULL;

	//::PostThreadMessage(m_nThreadID,WM_QUIT,0,0);
	CUtilThread::ShutdownThread(this,10*1000);
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      建立物理连接外壳函数

@param   CString ipAddress IP地址
@param	UINT port 端口

@retval     bool 成功或失败

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
bool CSCClient::Connect(CString ipAddress,UINT port)
{
	auto_ptr<FuncCommand<bool(CString,UINT)>> connectCommand(new FuncCommand<bool(CString,UINT)>(this,&CSCClient::ConnectImp));
	connectCommand->t0 = ipAddress;
	connectCommand->t1 = port;
	this->PostThreadMessage(SC_MSG_EXEC_COMMAND,NULL,(LPARAM)(connectCommand.get()));
	return WaitForCommandComplete(connectCommand.get());
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      实际建立连接函数

@param   CString ipAddress IP地址
@param	UINT port 端口

@retval     bool 成功或失败

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
bool CSCClient::ConnectImp(CString ipAddress,UINT port)
{
	if(!m_Socket->Create(0,SOCK_STREAM))
	{
		return false;
	}
	if(FALSE == m_Socket->Connect(ipAddress,port))
	{
		CloseImp();
		return false;
	}
	m_PauseSend = false;
	m_IsClosed = false;
	return true;
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      关闭物理连接外壳函数

@param      无

@retval     bool 成功或失败

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
bool CSCClient::Close()
{
	auto_ptr<FuncCommand<bool ()>> closeCommand(new FuncCommand<bool ()>(this,&CSCClient::CloseImp));
	this->PostThreadMessage(SC_MSG_EXEC_COMMAND,NULL,(LPARAM)(closeCommand.get()));
	return WaitForCommandComplete(closeCommand.get());
	//FuncCommand<bool ()> closeCommand(this,&CSCClient::CloseImp);
	//this->PostThreadMessage(SC_MSG_EXEC_COMMAND,NULL,(LPARAM)(&closeCommand));
	//return WaitForCommandComplete(&closeCommand);
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      实际关闭物理连接函数

@param      无

@retval     bool 成功或失败

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
bool CSCClient::CloseImp()
{
	m_Socket->ShutDown();
	m_Socket->Close();
	closesocket((SOCKET)(*m_Socket));
	OnSocketClosed(CLOSEFROMLOCALCODE);
	m_IsClosed = true;
	return true;
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      发送外壳函数

@param      CSCCommand* command需要发送的上位命令 

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::Send(CSCCommand* command)
{
	if(m_IsClosed)
	{
		command->OnComplete(SC_ERR_NOT_RESPONSE);
		return;
	}
	TRANSFER_COMMAND_CODE sendImmidateCode[] = {CMD_GENERIC_ACK,CMD_GENERIC_NACK,CMD_ENQUIRE_LINK};
	TRANSFER_COMMAND_CODE commandID = (TRANSFER_COMMAND_CODE)command->GetHeader().nwTransId.bCmdID;
	if(CValidation::IsInRange(commandID,sendImmidateCode))
	{
		SendImp(command);
	}
	else
	{
		this->PostThreadMessage(SC_MSG_POST_MESSAGE,NULL,(LPARAM)command);
	}
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      实际发送命令函数

@param     CSCCommand* command 需要发送的上位命令 

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::SendImp(CSCCommand* command)
{
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" <-"));
	
	if(NULL == command){
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T("传递空的指针，会使程序崩溃 ->"));
		return;
	}

	m_Helper->StopTimer();
	CSCClientHelper::CARRAY_PACKAGE_DATA packages;
	m_Helper->MakePackages(command,packages);
	for(int i=0;i<packages.GetSize();i++)
	{
		CSCClientHelper::LPPACKAGE_DATA& package = packages[i+1];
		m_Socket->Send(package->bData,package->nLen);
		delete package;
		package = NULL;
	}
	nackResendTimes=0;
	timeoutResendTimes = 0;
	if(command->GetHeader().nwTransId.bCmdID != CMD_GENERIC_ACK&&command->GetHeader().nwTransId.bCmdID != CMD_GENERIC_NACK)
	{
		if(m_LocalCommand!=NULL)
		{
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
			m_LocalCommand->OnComplete(SC_ERR_INVALID_SEQUENCE);
			m_LocalCommand = NULL;
		}
		command->Completed.AddHandler(this,&CSCClient::OnSCCommandCompleted);
		m_LocalCommand = command;
		m_Helper->StartSendTimeOutTimer();
	}
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
}

//////////////////////////////////////////////////////////////////////////
/*
@brief     重新发送 

@param bool becauseNACK true由于NACK发送，false超时发送     

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::Resend(bool becauseNACK)
{
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" <-"));
	if(m_LocalCommand == NULL)
	{
		return;
	}
	m_Helper->StopTimer();
	bool closeConnect=false;
	if(becauseNACK)
	{
		nackResendTimes ++;
		if(nackResendTimes>=m_Parameter.nackResendMaxTimes)
		{
			closeConnect = true;
		}
	}
	else{
		timeoutResendTimes++;
		if(timeoutResendTimes>=m_Parameter.timeoutResendMaxTimes)
		{
			closeConnect = true;
		}
	}
	if(closeConnect)
	{
		m_LocalCommand->OnComplete(SC_ERR_NOT_RESPONSE);
		m_LocalCommand = NULL;
		m_HostSvc->PostMessage(SC_MSG_RECONNECT,NULL,NULL);
		return;
	}
	else
	{
		m_LocalCommand->SetIsReceived(FALSE);
		CSCClientHelper::CARRAY_PACKAGE_DATA packages;
		m_Helper->MakePackages(m_LocalCommand,packages);
		for(int i=0;i<packages.GetSize();i++)
		{			
			CSCClientHelper::LPPACKAGE_DATA& package = packages[i+1];
			m_Socket->Send(package->bData,package->nLen);
			delete package;
			package = NULL;
		}
		m_Helper->StartSendTimeOutTimer();
	}
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      Socket开始收到一条消息回调函数

@param	int nErrorCode     错误代码

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnSocketStartReceiveOneMessage(int nErrorCode)
{
	m_PauseSend = true;
	m_Helper->StopTimer();
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      Socket接收完一条消息的回调函数

@param     bool success 是否接收成功
@param	VARIABLE_DATA&接收成功的数据

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnSocketEndReceiveOneMessage(bool success,VARIABLE_DATA& package)
{
	if(!success)
	{
		m_HostSvc->PostMessage( SC_MSG_RECONNECT, NULL,NULL);
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" -> !receiveImpSuccess"));
		m_PauseSend = false;
		return;
	}
	SC_NACK_CODE nackCode;
	bool isPackageOK =  m_Helper->IsPackageOK(package,nackCode);
	if(!isPackageOK)
	{
		CMD_HEADER header;
		header.Deserialize(package.lpData+LEN_START_TAG);
		SendNACK(header.nwTransId,nackCode);
		if(m_Helper->IsKeyError(nackCode))
		{
			m_HostSvc->PostMessage(SC_MSG_RECONNECT,NULL,NULL);
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" -> key error. nackcode: %.2X"),nackCode);
		}
		else
		{
			m_Helper->StartReceiveTimeOutTimer();
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->nack. nack code: %.2X"),nackCode);
		}
		m_PauseSend = false;
		return;
	}

	bool commandReceiveComplete = m_Helper->SaveOnePackage(package);
	if(!commandReceiveComplete)
	{
		m_Helper->StartReceiveTimeOutTimer();
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" -> !commandReceiveComplete"));
		m_PauseSend = false;
		return;
	}
	VARIABLE_DATA commandMsg;
	m_Helper->ComposePackagesToCommandMsg(commandMsg);
	bool isCommandMsgOK = m_Helper->IsCommandMsgOK(commandMsg,nackCode);
	if(!isCommandMsgOK)
	{
		CMD_HEADER header;
		header.Deserialize(package.lpData+LEN_START_TAG);
		SendNACK(header.nwTransId,nackCode);
		if(m_Helper->IsKeyError(nackCode))
		{
			m_Parameter.hostSvc->PostMessage(SC_MSG_RECONNECT,NULL,NULL);
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" -> key error. nack code:%.2X"),nackCode);
		}
		else
		{
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" -> nack. nack code:%.2X"),nackCode);
			m_Helper->StartReceiveTimeOutTimer();
		}
		m_PauseSend = false;
		return;
	}
	CSCCommand* remoteCommand=CreateCommand(commandMsg);

	long lValidResult = remoteCommand->IsValidCommand();
	if(lValidResult != SP_SUCCESS)
	{
		SC_NACK_CODE nackCode = (SC_NACK_CODE)lValidResult;
		SendNACK(remoteCommand->GetHeader().nwTransId,nackCode);
		bool isKeyError = m_Helper->IsKeyError(nackCode);
		if(isKeyError)
		{
			m_HostSvc->PostMessage(SC_MSG_RECONNECT,NULL,NULL);
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" -> key error. nack code %.2X"),nackCode);
		}
		else
		{
			m_Helper->StartReceiveTimeOutTimer();
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" -> nack. nack code %.2X"),nackCode);
		}
		m_PauseSend = false;
		return;
	}
	OnRemoteCommandArravial(remoteCommand);
	m_Helper->StartEnquireLinkTimer();
	m_PauseSend = false;
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      开始发送一条消息回调函数

@param      const unsigned char* 消息内容
@param	int消息长度

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnSocketStartSendOneMessage(const unsigned char*, int)
{

}

//////////////////////////////////////////////////////////////////////////
/*
@brief      一条消息发送完成回调函数

@param      const unsigned char* 消息内容
@param	int消息长度

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnSocketEndSendOneMessage(const unsigned char*, int)
{

}

//////////////////////////////////////////////////////////////////////////
/*
@brief      Socket关闭时回调函数

@param   int nErrorCode 错误代码   

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnSocketClosed(int nErrorCode)
{
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" <-"));
	m_PauseSend = true;
	m_Helper->StopTimer();
	if(m_LocalCommand!=NULL)
	{
		m_LocalCommand->OnComplete(SC_ERR_NOT_RESPONSE);
		m_LocalCommand = NULL;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T("->"));
	}
	while(!m_PendingCommand.IsEmpty())
	{
		CSCCommand* command = (CSCCommand*)m_PendingCommand.RemoveHead();
		if(NULL != command){
			command->OnComplete(SC_ERR_NOT_RESPONSE);
		}
	}
	m_PendingCommand.RemoveAll();
	// 设置重新连接计时器开启
	if(nErrorCode!= CLOSEFROMLOCALCODE)
	{
		BOOL bRet = FALSE;
		do 
		{
			bRet = m_HostSvc->PostMessage(SC_MSG_RECONNECT,NULL,NULL);
			Sleep(300);
		} while (!bRet);
	}
	m_IsClosed = true;
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T("->"));
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      发送NACK

@param   NETWORK_TRANS_ID responseForNTID 源消息NTID
@param   SC_NACK_CODE nackCode   nack代码

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::SendNACK(NETWORK_TRANS_ID responseForNTID,SC_NACK_CODE nackCode)
{
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" <-"));
	CSCGenericNack nackCommand;
	nackCommand.SetResponseNTID(responseForNTID);
	nackCommand.SetNACKCode(nackCode);
	nackCommand.Execute();
	nackCommand.OnComplete(SP_SUCCESS);
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      发送ACK

@param      NETWORK_TRANS_ID responseForNTID 源消息NTID

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::SendACK(NETWORK_TRANS_ID responseForNTID)
{
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" <-"));
	CSCGenericAck ackCommand;
	ackCommand.SetResponseNTID(responseForNTID);
	ackCommand.Execute();
	ackCommand.OnComplete(SP_SUCCESS);
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
}

//////////////////////////////////////////////////////////////////////////
/*
@brief     根据命令内容，创建命令对象 

@param    VARIABLE_DATA& commandMsg 命令内容  

@retval     CSCCommand* 生成的命令代码

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
CSCCommand* CSCClient::CreateCommand(VARIABLE_DATA& commandMsg)
{
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T("->"));
	CMD_HEADER header;
	header.Deserialize(commandMsg.lpData+LEN_START_TAG);
	UINT contentLength = commandMsg.nLen - LEN_START_TAG_CMD_HEADER_END_TAG; /*START_TAG + END_TAG*/
	if(header.bCrcType!=0x00)
	{
		contentLength-=LEN_CRC;//有校验，减去校验位长度
	}

	if(contentLength<0)
	{
		contentLength = 0;
	}
	CSCCommand* command = NULL;
	switch(header.nwTransId.bCmdID)
	{
	case CMD_CONNECT_REQUEST:
		command = new CSCConnectRequest;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCConnectRequest"));
		break;
	case CMD_CONNECT_REQUEST_REPLY:
		command = new CSCConnectRequestReply;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCConnectRequestReply"));
		break;
	case CMD_GENERIC_ACK:
		command = new CSCGenericAck;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCGenericAck"));
		break;
	case CMD_GENERIC_NACK:
		command = new CSCGenericNack;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCGenericNack"));
		break;
	case CMD_DATA_TRANSFER:
		command = new CSCDataMsg;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCDataMsg"));
		break;
	case CMD_DATA_TRANSFER_REPLY:
		command = new CSCDataMsgReply;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCDataMsgReply"));
		break;
	case CMD_ENQUIRE_LINK:
		command = new CSCEnquireLink;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCEnquireLink"));
		break;
	case CMD_ENQUIRE_LINK_REPLY:
		command = new CSCEnquireLinkReply;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCEnquireLinkReply"));
		break;
	default:
		command = new CSCCommand;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" CSCCommand"));
		break;
	}
	command->SetAutoDeleted(TRUE);
	command->SetIsRemote(TRUE);
	command->SetHeader(&header);
	command->DeserializeBody(commandMsg.lpData+LEN_START_TAG_CMD_HEADER,contentLength);
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
	return command;
}


//////////////////////////////////////////////////////////////////////////
/*
@brief      上传命令到达时的处理函数

@param    CSCCommand* command 上位命令  

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnRemoteCommandArravial(CSCCommand* command)
{
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" <-"));
	BYTE remoteCommandID = command->GetHeader().nwTransId.bCmdID;
	BYTE localCommandID = m_LocalCommand == NULL ? 0 : m_LocalCommand->GetHeader().nwTransId.bCmdID;
	if(localCommandID == CMD_ENQUIRE_LINK)
	{
		m_LocalCommand->OnComplete(SP_SUCCESS);
		m_LocalCommand = NULL;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
	}
	if(remoteCommandID == CMD_ENQUIRE_LINK_REPLY)
	{
		delete command;
		command = NULL;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
		return;
	}

	BYTE needResponseCommands[] = {CMD_DATA_TRANSFER};
	bool commandNeedResponse = CValidation::IsInRange(remoteCommandID,needResponseCommands);
	if(commandNeedResponse)
	{
		if(m_LocalCommand!=NULL)
		{
			command->m_InterruptedCommand = m_LocalCommand;
			command->Completing.AddHandler(this,&CSCClient::OnSCDataMsgCompleting);
			m_LocalCommand = NULL;
		}
		SendACK(command->GetHeader().nwTransId);
		m_HostSvc->PostMessage(SC_MSG_DATAMSG,NULL,(LPARAM)command);
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" SC_MSG_DATAMSG"));
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
		return;
	}
	if(m_LocalCommand==NULL)
	{
		delete command;
		command = NULL;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
		return;
	}
	if(remoteCommandID ==CMD_GENERIC_ACK)
	{
		if(!m_LocalCommand->IsReceived())
		{
			m_LocalCommand->SetIsReceived(TRUE);
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" SetIsReceived"));
			if(!m_LocalCommand->IsNeedReply())
			{
				m_LocalCommand->OnComplete(SP_SUCCESS);
				m_LocalCommand = NULL;
				theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
			}
		}
		if (command)
		{
			delete command;
			command = NULL;
		}
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
		return;
	}
	if(remoteCommandID == CMD_GENERIC_NACK)
	{
		if(!m_LocalCommand->IsReceived())
		{
			Resend(true);
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" Resend"));
		}
		delete command;
		command = NULL;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
		return;
	}
	if(localCommandID == CMD_CONNECT_REQUEST && remoteCommandID== CMD_CONNECT_REQUEST_REPLY
		&& m_LocalCommand->IsReceived()
		)
	{
		SendACK(command->GetHeader().nwTransId);
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" SendACK"));
		m_LocalCommand->SetReplyCommand(dynamic_cast<CSCResponseCommand*>(command));
		m_LocalCommand->OnComplete(SP_SUCCESS);
		m_LocalCommand = NULL;
		theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
		return;
	}
	if(localCommandID == CMD_DATA_TRANSFER && remoteCommandID == CMD_DATA_TRANSFER_REPLY
		)
	{
		CSCResponseCommand* responseCommand = dynamic_cast<CSCResponseCommand*>(command);
		if(responseCommand!=NULL && memcmp(&m_LocalCommand->GetHeader().nwTransId,&responseCommand->GetResponseNTID(),sizeof(m_LocalCommand->GetHeader().nwTransId))==0)
		{
			SendACK(command->GetHeader().nwTransId);
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" SendACK"));
			m_LocalCommand->SetReplyCommand(dynamic_cast<CSCResponseCommand*>(responseCommand));
			m_LocalCommand->OnComplete(SP_SUCCESS);
			m_LocalCommand = NULL;
			theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
		}

		return;
	}
	SendNACK(command->GetHeader().nwTransId,SC_NACK_CODE::OTHER_ERR);
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" SendNACK SC_NACK_CODE::OTHER_ERR"));
	delete command;
	command = NULL;
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));

}

//////////////////////////////////////////////////////////////////////////
/*
@brief      接收超时响应函数

@param      无

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnReceiveTimeout()
{
	if(m_LocalCommand!=NULL)
	{
		m_LocalCommand->OnComplete(INVALID_PDU_LENGTH);
		m_LocalCommand = NULL;
	}
	m_HostSvc->PostMessage(SC_MSG_RECONNECT,NULL,NULL);
	theSC_Client_Trace->WriteData(__FILENAME__,_T(__FUNCTION__),__LINE__,_T(" ->"));
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      发送消息超时响应函数

@param      无

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnSendTimeout()
{
	Resend(false);
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      心跳计时响应函数

@param      无

@retval     无

@exception  
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnEnquirelink()
{
	CSCEnquireLink* pEnquireLink = new CSCEnquireLink;
	pEnquireLink->SetAutoDeleted(TRUE);
	pEnquireLink->Execute();
}


//////////////////////////////////////////////////////////////////////////
/*
@brief      其他线程将一个命令抛到当前线程执行命令

@param      WPARAM wParam 无意义
@param      LPARAM lParam CRequestItem* 命令对象

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void  CSCClient::OnExecCommand(WPARAM wParam,LPARAM lParam)
{
	CCommand* item = (CCommand*)lParam;
	item->OnComplete(item->Execute());
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      添加发送命令到队列中

@param      WPARAM wParam 无意义
@param      LPARAM lParam CRequestItem* 命令对象

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnPostCommand(WPARAM wParam,LPARAM lParam)
{
	CSCCommand* command = (CSCCommand*)lParam;
	m_PendingCommand.AddTail(command);
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      线程空闲时执行

@param      

@retval     

@exception  
*/
//////////////////////////////////////////////////////////////////////////
BOOL CSCClient::OnIdle(LONG lCount)
{
	Sleep(1);
	if (m_PauseSend) {
		return TRUE;
	}
	if (m_PendingCommand.IsEmpty()) {
		return TRUE;
	}
	if(m_LocalCommand!=NULL)
	{
		return TRUE;
	}
	CSCCommand* command = (CSCCommand*)m_PendingCommand.RemoveHead();
	SendImp(command);
}

//////////////////////////////////////////////////////////////////////////
/*
@brief      当上位命令完成时回调函数

@param     CRequestItem* requestItem 上位命令 

@retval     无

@exception  无
*/
//////////////////////////////////////////////////////////////////////////
void CSCClient::OnSCDataMsgCompleting(CCommand* requestItem)
{
	requestItem->Completing.RemoveHandler(this,&CSCClient::OnSCDataMsgCompleting);
	CSCCommand* command = dynamic_cast<CSCCommand*>(requestItem);
	if(command==NULL || command->m_InterruptedCommand == NULL)
	{
		return;
	}
	//将中断的命令放在PendingList中。
	m_PendingCommand.AddHead(command->m_InterruptedCommand);
	command->m_InterruptedCommand = NULL;
}


void CSCClient::OnSCCommandCompleted(CCommand* requestItem)
{
	if(requestItem == m_LocalCommand)
	{
		m_LocalCommand = NULL;
	}
	m_PendingCommand.Remove(requestItem);
}